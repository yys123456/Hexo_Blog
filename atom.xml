<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yys_c</title>
  
  
  <link href="/yys123456.github.io/atom.xml" rel="self"/>
  
  <link href="https://yys123456.github.io/"/>
  <updated>2019-07-25T08:41:40.948Z</updated>
  <id>https://yys123456.github.io/</id>
  
  <author>
    <name>yu yan song</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>静态链表</title>
    <link href="https://yys123456.github.io/2019/07/25/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/"/>
    <id>https://yys123456.github.io/2019/07/25/静态链表/</id>
    <published>2019-07-25T05:14:27.000Z</published>
    <updated>2019-07-25T08:41:40.948Z</updated>
    
    <content type="html"><![CDATA[<p>由于C++语言中具有指针这一种数据类型，指针用来指示结点的存储首地址，所以可以使用前一个结点中的next域中所存放的地址来指示下一个结点的位置，从而可以方便地实现单链表的结构，但是对于不设指针的高级语言中，就无法使用指针来实现单链表了。虽然没有指针这种数据类型，并不代表无法实现链表数据结构，链表实际上就是一个一个结点通过地址的关系链接起来，主要是为了满足插入与删除和动态分配结点的方便性的数据结构。所以可以使用结构体数组来实现静态链表。为了更具有一般性，<strong>以下使用Java语言来实现静态链表</strong>（以下称<strong>SL</strong>）。</p><h3 id="1-结点的结构"><a href="#1-结点的结构" class="headerlink" title="1. 结点的结构"></a>1. 结点的结构</h3><p>一个结点中含有自己本身的数据和下一个结点的位置信息（即数组下标）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticList</span></span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">char</span> data;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">int</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.  具体实现"></a>2.  具体实现</h3><p>对比C++中单链表的实现，SL需要注意</p><ol><li>指针单链表的建立过程中需要动态分配结点，使用系统函数malloc实现，而SL使用数组实现无法使用malloc；</li><li>指针单链表对结点的删除需要使用系统的free函数，而对于SL，没用相关的函数；</li></ol><h4 id="1-建立"><a href="#1-建立" class="headerlink" title="1. 建立"></a>1. 建立</h4><p>由于链表的建立都是需要通过动态分配结点并连接，所以在建立SL之前需要初始化可分配的结点资源。在使用数值来进行静态链表的建立时，需要从可分配结点资源中获取一个结点，然后将其作为头结点或存储数据的结点。简单来说，可分配结点资源就是一个静态链表，每次从资源中获取一个结点就是从其中屏蔽（删除）一个结点，然后让此结点在我所建立的链表中可见。</p><p>初始化资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">()</span></span>&#123;<span class="comment">//初始化资源，构造方法</span></span><br><span class="line">        a=<span class="keyword">new</span> StaticList[LEN];<span class="comment">//总资源数LEN-1个，0号不要</span></span><br><span class="line">        len=<span class="number">0</span>;<span class="comment">//设置链表初始长度为0</span></span><br><span class="line">        a[<span class="number">0</span>]=<span class="keyword">new</span> StaticList();</span><br><span class="line">        a[<span class="number">0</span>].next=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;LEN;i++) &#123;</span><br><span class="line">            a[i]=<span class="keyword">new</span> StaticList();</span><br><span class="line">            <span class="keyword">if</span> (i == LEN - <span class="number">1</span>) &#123;</span><br><span class="line">                a[i].next = <span class="number">0</span>;<span class="comment">//最后一个可分配结点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a[i].next = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>分配结点方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">malloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=a[<span class="number">0</span>].next;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">0</span>) &#123;</span><br><span class="line">            a[<span class="number">0</span>].next = a[i].next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>尾插法创建带头结点的SL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createList</span><span class="params">(<span class="keyword">char</span> ...s)</span></span>&#123;<span class="comment">//尾插法</span></span><br><span class="line">        head=malloc();<span class="comment">//0表示失败</span></span><br><span class="line">        <span class="keyword">int</span> r=head;<span class="comment">//r是尾指针，标记当前链表的最后一个结点</span></span><br><span class="line">        a[head].next=<span class="number">0</span>;<span class="comment">//0对应指针单链表中的NULL</span></span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> q=malloc();</span><br><span class="line">                a[q].data=s[i];</span><br><span class="line">                a[q].next=a[r].next;</span><br><span class="line">                a[r].next=q;</span><br><span class="line">                r=q;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"空间不够"</span>);<span class="comment">//实际上s的最长长度为LEN-2，s为实际数据个数</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2. 遍历"></a>2. 遍历</h4><p>使用遍历来测试SL是否建立成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showList</span><span class="params">()</span></span>&#123;<span class="comment">//遍历</span></span><br><span class="line">       <span class="keyword">int</span> h=a[head].next;</span><br><span class="line">       <span class="keyword">while</span>(h!=<span class="number">0</span>)&#123;</span><br><span class="line">           System.out.println(h+<span class="string">" "</span>+a[h].data+<span class="string">" "</span>+a[h].next);</span><br><span class="line">           h=a[h].next;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3-元素定位"><a href="#3-元素定位" class="headerlink" title="3. 元素定位"></a>3. 元素定位</h4><ol><li>特定位置元素定位</li></ol><p>类似于指针单链表，使用一个计数器j，并满足查找过程中链表没有走到尽头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StaticList <span class="title">locateElem</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="comment">//按照个数来定位</span></span><br><span class="line">       <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> h=a[head].next;</span><br><span class="line">       <span class="keyword">for</span>(;j&lt;i&amp;&amp;h!=<span class="number">0</span>;j++,h=a[h].next);</span><br><span class="line">       <span class="keyword">if</span>(j&gt;i||h==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">return</span> a[h];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol><li>特定值的元素定位</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StaticList <span class="title">locateElem</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h=a[head].next;</span><br><span class="line">       <span class="keyword">while</span>(h!=<span class="number">0</span>&amp;&amp;a[h].data!=c)h=a[h].next;</span><br><span class="line">       <span class="keyword">if</span>(h==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">return</span> a[h];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="4-插入"><a href="#4-插入" class="headerlink" title="4. 插入"></a>4. 插入</h4><p>类似于指针单链表，插入操作需要先走到需要插入位置的前一个位置，如果在链表中存在这个位置，那么就在它后面执行插入操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> h=head;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span>(j&lt;i-<span class="number">1</span>&amp;&amp;h!=<span class="number">0</span>)&#123;</span><br><span class="line">         j++;</span><br><span class="line">         h=a[h].next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(j&gt;i-<span class="number">1</span>||h==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">2</span>;<span class="comment">//插入位置不合法</span></span><br><span class="line">     <span class="keyword">int</span> p=malloc();</span><br><span class="line">     <span class="keyword">if</span>(p==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//无剩余空间</span></span><br><span class="line">     a[p].data=c;</span><br><span class="line">     a[p].next=a[h].next;</span><br><span class="line">     a[h].next=p;</span><br><span class="line">     len++;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//正常插入</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="5-删除"><a href="#5-删除" class="headerlink" title="5. 删除"></a>5. 删除</h4><p>类似于指针单链表，删除操作需要先走到需要插入位置的前一个位置，如果在链表中存在这个位置，并且下一个位置有结点，就执行删除操作，但由于SL的所有结点都是从一个资源数组得来的，所以对于一个结点的释放，就是将这个结点还给资源数组，而这个操作需要自己实现free方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="comment">//将还回的结点i（逻辑上）插入到a[0]后面</span></span><br><span class="line">       a[i].next=a[<span class="number">0</span>].next;</span><br><span class="line">       a[<span class="number">0</span>].next=i;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="1-按位序删除"><a href="#1-按位序删除" class="headerlink" title="1. 按位序删除"></a>1. 按位序删除</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="comment">//删除第i个结点</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h=head;</span><br><span class="line">        <span class="keyword">while</span>(a[h].next!=<span class="number">0</span>&amp;&amp;j&lt;i-<span class="number">1</span>)&#123;</span><br><span class="line">            j++;</span><br><span class="line">            h=a[h].next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;i-<span class="number">1</span>||a[h].next==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p=a[h].next;</span><br><span class="line">        a[h].next=a[p].next;</span><br><span class="line">        free(p);</span><br><span class="line">        len--;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="2-按值删除（删除特定值的结点）"><a href="#2-按值删除（删除特定值的结点）" class="headerlink" title="2. 按值删除（删除特定值的结点）"></a>2. 按值删除（删除特定值的结点）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h=head;</span><br><span class="line">        <span class="keyword">while</span>(a[h].next!=<span class="number">0</span>&amp;&amp;a[a[h].next].data!=c)h=a[h].next;</span><br><span class="line">        <span class="keyword">if</span>(a[h].next==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不存在值为c的结点</span></span><br><span class="line">        <span class="keyword">int</span> p=a[h].next;</span><br><span class="line">        a[h].next=a[p].next;</span><br><span class="line">        free(p);</span><br><span class="line">        len--;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-基于静态链表求集合A与B的对称差"><a href="#3-基于静态链表求集合A与B的对称差" class="headerlink" title="3. 基于静态链表求集合A与B的对称差"></a>3. 基于静态链表求集合A与B的对称差</h3><p>由于上面已经将插入与删除的方法定义完备，所以可以直接基于对称差的描述来实现算法。对称差公式如下</p><script type="math/tex; mode=display">A\oplus{B}=(A\cup{B})-(A\cap{B})=(A-B)\cup(B-A)</script><p>所以求A和B的对称差就可以对B进行遍历，然后检查A，将A中$A\cap{B}$部分删除，然后将A中没有的数据包装成结点，插入A的末尾。最后返回处理后的A对应的引用变量。</p><p>复杂度极高的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Main <span class="title">process</span><span class="params">(Main m1,Main m2)</span></span>&#123;<span class="comment">//求对称差 </span></span><br><span class="line">        <span class="comment">//从m2中取出元素，然后再m1中遍历，若相同就删除，若找不到就在尾部插入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m2.len;i++)&#123;<span class="comment">//遍历</span></span><br><span class="line">            <span class="keyword">if</span>(m1.locateElem(m2.locateElem(i).data)!=<span class="keyword">null</span>)&#123;<span class="comment">//遍历</span></span><br><span class="line">                m1.delete(m2.locateElem(i).data);<span class="comment">//遍历</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                m1.insert(m1.len+<span class="number">1</span>,m2.locateElem(i).data);<span class="comment">//遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度较低的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Main <span class="title">process1</span><span class="params">(Main m1,Main m2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h1,h2;</span><br><span class="line">        <span class="keyword">int</span> pre;<span class="comment">//跟进指针，无论m1中是否有相应的元素 pre始终指向h1的前一个结点</span></span><br><span class="line">        h2=m2.a[m2.head].next;<span class="comment">//指向m2第一个结点</span></span><br><span class="line">        <span class="keyword">while</span>(h2!=<span class="number">0</span>)&#123;</span><br><span class="line">            pre=m1.head;<span class="comment">//指向m1的头结点</span></span><br><span class="line">            h1=m1.a[pre].next;</span><br><span class="line">            <span class="keyword">while</span>(h1!=<span class="number">0</span>&amp;&amp;m1.a[h1].data!=m2.a[h2].data)&#123;</span><br><span class="line">                pre=h1;</span><br><span class="line">                h1=m1.a[h1].next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(h1==<span class="number">0</span>)&#123;<span class="comment">//没有相等的结点</span></span><br><span class="line">                <span class="keyword">int</span> p=m1.malloc();</span><br><span class="line">                m1.a[p].data=m2.a[h2].data;</span><br><span class="line">                m1.a[p].next=m1.a[pre].next;</span><br><span class="line">                m1.a[pre].next=p;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                m1.a[pre].next=m1.a[h1].next;</span><br><span class="line">                m1.free(h1);</span><br><span class="line">            &#125;</span><br><span class="line">            h2=m2.a[h2].next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>时间复杂度分析</p><p>由于每次取出m2中的一个元素后都要对m1遍历一遍，所以时间复杂度为  $ O(LEN_{m1}\times{LEN_{m2}})$。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>静态单链表和动态单链表非常相似，动态单链表使用结构体并借助系统函数malloc和free来实现系统内存资源的分配链表的建立和结点的插入和删除。而静态单链建立时所分配的资源是提前建立的结构数组的资源，所以需要手工实现malloc和free函数。其他的方面区别不是很大。</p><p>对于静态链表SL，需要了解</p><ol><li>SL的建立（需要直到建立SL之前需要做的事情（初始化资源、实现malloc方法（隐蔽）））；</li><li>SL中结点的删除（free方法的实现（归还））；</li><li>SL的插入操作；</li><li>SL中元素的定位；</li></ol><h3 id="5-测试程序"><a href="#5-测试程序" class="headerlink" title="5. 测试程序"></a>5. 测试程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticList</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEN=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> StaticList[] a;<span class="comment">//备用链表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">static</span> java.util.Scanner scn=<span class="keyword">new</span> java.util.Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">()</span></span>&#123;<span class="comment">//初始化资源</span></span><br><span class="line">        a=<span class="keyword">new</span> StaticList[LEN];<span class="comment">//带头结点的静态链表</span></span><br><span class="line">        len=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//System.out.println(a[0]==null?"NULL":"yes");</span></span><br><span class="line">        a[<span class="number">0</span>]=<span class="keyword">new</span> StaticList();</span><br><span class="line">        a[<span class="number">0</span>].next=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;LEN;i++) &#123;</span><br><span class="line">            a[i]=<span class="keyword">new</span> StaticList();</span><br><span class="line">            <span class="keyword">if</span> (i == LEN - <span class="number">1</span>) &#123;</span><br><span class="line">                a[i].next = <span class="number">0</span>;<span class="comment">//最后一个可分配结点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a[i].next = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">malloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=a[<span class="number">0</span>].next;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">0</span>) &#123;</span><br><span class="line">            a[<span class="number">0</span>].next = a[i].next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createList</span><span class="params">(<span class="keyword">char</span> ...s)</span></span>&#123;<span class="comment">//尾插法</span></span><br><span class="line">        head=malloc();<span class="comment">//0表示失败</span></span><br><span class="line">        <span class="keyword">int</span> r=head;</span><br><span class="line">        a[head].next=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> q=malloc();</span><br><span class="line">                a[q].data=s[i];</span><br><span class="line">                a[q].next=a[r].next;</span><br><span class="line">                a[r].next=q;</span><br><span class="line">                r=q;<span class="comment">//</span></span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"空间不够"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">StaticList <span class="title">locateElem</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="comment">//按照个数来定位</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> h=a[head].next;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;i&amp;&amp;h!=<span class="number">0</span>;j++,h=a[h].next);</span><br><span class="line">        <span class="keyword">if</span>(j&gt;i||h==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a[h];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showList</span><span class="params">()</span></span>&#123;<span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">int</span> h=a[head].next;</span><br><span class="line">        <span class="keyword">while</span>(h!=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(h+<span class="string">" "</span>+a[h].data+<span class="string">" "</span>+a[h].next);</span><br><span class="line">            h=a[h].next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">StaticList <span class="title">locateElem</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h=a[head].next;</span><br><span class="line">        <span class="keyword">while</span>(h!=<span class="number">0</span>&amp;&amp;a[h].data!=c)h=a[h].next;</span><br><span class="line">        <span class="keyword">if</span>(h==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a[h];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h=head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(j&lt;i-<span class="number">1</span>&amp;&amp;h!=<span class="number">0</span>)&#123;</span><br><span class="line">            j++;</span><br><span class="line">            h=a[h].next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;i-<span class="number">1</span>||h==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> p=malloc();</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        a[p].data=c;</span><br><span class="line">        a[p].next=a[h].next;</span><br><span class="line">        a[h].next=p;</span><br><span class="line">        len++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        a[i].next=a[<span class="number">0</span>].next;</span><br><span class="line">        a[<span class="number">0</span>].next=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h=head;</span><br><span class="line">        <span class="keyword">while</span>(a[h].next!=<span class="number">0</span>&amp;&amp;a[a[h].next].data!=c)h=a[h].next;</span><br><span class="line">        <span class="keyword">if</span>(a[a[h].next].next==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p=a[h].next;</span><br><span class="line">        a[h].next=a[p].next;</span><br><span class="line">        free(p);</span><br><span class="line">        len--;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h=head;</span><br><span class="line">        <span class="keyword">while</span>(a[h].next!=<span class="number">0</span>&amp;&amp;j&lt;i-<span class="number">1</span>)&#123;</span><br><span class="line">            j++;</span><br><span class="line">            h=a[h].next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(j&gt;i-<span class="number">1</span>||a[h].next==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p=a[h].next;</span><br><span class="line">        a[h].next=a[p].next;</span><br><span class="line">        free(p);</span><br><span class="line">        len--;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Main <span class="title">process</span><span class="params">(Main m1,Main m2)</span></span>&#123;<span class="comment">//求对称差</span></span><br><span class="line">        <span class="comment">//从m2中取出元素，然后再m1中遍历，若相同就删除，若找不到就在尾部插入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m2.len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m1.locateElem(m2.locateElem(i).data)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                m1.delete(m2.locateElem(i).data);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//System.out.println(m2.locateElem(i).data);</span></span><br><span class="line">                m1.insert(m1.len+<span class="number">1</span>,m2.locateElem(i).data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Main <span class="title">process1</span><span class="params">(Main m1,Main m2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h1,h2;</span><br><span class="line">        <span class="keyword">int</span> pre;</span><br><span class="line">        h2=m2.a[m2.head].next;<span class="comment">//指向m2第一个结点</span></span><br><span class="line">        <span class="comment">//System.out.println(h2);</span></span><br><span class="line">        <span class="keyword">while</span>(h2!=<span class="number">0</span>)&#123;</span><br><span class="line">            pre=m1.head;<span class="comment">//指向m1的头结点</span></span><br><span class="line">            h1=m1.a[pre].next;</span><br><span class="line">            <span class="keyword">while</span>(h1!=<span class="number">0</span>&amp;&amp;m1.a[h1].data!=m2.a[h2].data)&#123;</span><br><span class="line">                pre=h1;</span><br><span class="line">                h1=m1.a[h1].next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(h1==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"插入"</span>);</span><br><span class="line">                <span class="keyword">int</span> p=m1.malloc();</span><br><span class="line">                m1.a[p].data=m2.a[h2].data;</span><br><span class="line">                m1.a[p].next=m1.a[pre].next;</span><br><span class="line">                m1.a[pre].next=p;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(m1.a[h1].data);</span><br><span class="line">                m1.a[pre].next=m1.a[h1].next;</span><br><span class="line">                m1.free(h1);</span><br><span class="line">            &#125;</span><br><span class="line">            h2=m2.a[h2].next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span></span>&#123;</span><br><span class="line">        Main m=<span class="keyword">new</span> Main();</span><br><span class="line">        System.out.println(<span class="string">"生成静态链表m1："</span>);</span><br><span class="line">        m.createList(<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>);</span><br><span class="line">        m.showList();</span><br><span class="line">        System.out.println(<span class="string">"输入定位元素值："</span>);</span><br><span class="line">        <span class="keyword">char</span> c=scn.next().charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(m.locateElem(c)==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"null"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(m.locateElem(c).data+<span class="string">" "</span>+m.locateElem(c).next);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"输入插入参数："</span>);</span><br><span class="line">        m.insert(scn.nextInt(),scn.next().charAt(<span class="number">0</span>));</span><br><span class="line">        m.showList();</span><br><span class="line">        System.out.println(<span class="string">"输入删除参数："</span>);</span><br><span class="line">        m.delete(scn.nextInt());</span><br><span class="line">        m.showList();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"生成静态链表m2："</span>);</span><br><span class="line">        Main m2=<span class="keyword">new</span> Main();</span><br><span class="line">        m2.createList(<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>);</span><br><span class="line">        m2.showList();</span><br><span class="line">       <span class="comment">//System.out.println(m2.locateElem(m2.len).data);</span></span><br><span class="line">        System.out.println(<span class="string">"\n两个静态链表求对称差："</span>);</span><br><span class="line">        process1(m,m2).showList();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//StaticList s=m.locateElem('3');</span></span><br><span class="line">       <span class="comment">//StaticList s=m.locateElem(3);</span></span><br><span class="line">       <span class="comment">//System.out.println(s.data+" "+s.next);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于C++语言中具有指针这一种数据类型，指针用来指示结点的存储首地址，所以可以使用前一个结点中的next域中所存放的地址来指示下一个结点的位置，从而可以方便地实现单链表的结构，但是对于不设指针的高级语言中，就无法使用指针来实现单链表了。虽然没有指针这种数据类型，并不代表无法
      
    
    </summary>
    
      <category term="数据结构" scheme="https://yys123456.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="静态链表" scheme="https://yys123456.github.io/tags/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>1008</title>
    <link href="https://yys123456.github.io/2019/07/22/pat-1008/"/>
    <id>https://yys123456.github.io/2019/07/22/pat-1008/</id>
    <published>2019-07-22T12:30:42.000Z</published>
    <updated>2019-07-25T08:44:32.550Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//三步反转法 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>* s,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(n&gt;m)&#123;</span><br><span class="line">swap(s[m],s[n]);</span><br><span class="line">n--;</span><br><span class="line">m++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>*,<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;len&gt;&gt;k;</span><br><span class="line">    k%=len;</span><br><span class="line"><span class="keyword">int</span> *s=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)<span class="built_in">cin</span>&gt;&gt;s[i];</span><br><span class="line">reverse(s,len-k,len<span class="number">-1</span>);</span><br><span class="line">reverse(s,<span class="number">0</span>,len-k<span class="number">-1</span>);</span><br><span class="line">reverse(s,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)<span class="built_in">cout</span>&lt;&lt;s[i]&lt;&lt;(i==len<span class="number">-1</span>?<span class="string">""</span>:<span class="string">" "</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span>[] s;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span
      
    
    </summary>
    
      <category term="pat" scheme="https://yys123456.github.io/categories/pat/"/>
    
    
      <category term="pat" scheme="https://yys123456.github.io/tags/pat/"/>
    
  </entry>
  
  <entry>
    <title>单链表</title>
    <link href="https://yys123456.github.io/2019/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E9%93%BE%E8%A1%A8/"/>
    <id>https://yys123456.github.io/2019/07/19/数据结构———线性链表/</id>
    <published>2019-07-19T08:09:00.000Z</published>
    <updated>2019-07-25T08:43:35.135Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>线性表的表示方式有顺序表和链表两种，其中顺序表是一种随机存取结构，可以根据其逻辑顺序和存储顺序一致的特性从而可以根据其中某一个元素的地址推算出其他所有元素的地址，有公式如下，其中d是每一个元素所占的内存大小</p><script type="math/tex; mode=display">LOC_{a_j}=LOC_{a_i}+(j-i){\cdot}d</script><p>所以访问顺序表中i号元素的时间复杂度为</p><script type="math/tex; mode=display">O(1)</script><p>但是线性链表有所不同，线性链表并不是一种物理顺序和逻辑顺序相同的一种结构，线性链表中的元素在逻辑上是连续的，而物理上不一定是连续的，所以并不可以通过链表中某一个元素的位置推算出其他元素的位置。链表分为许多种类：单链表、循环链表、双向链表、静态链表。</p><script type="math/tex; mode=display">循环链表\left\{\begin{aligned}循环的单链表\\循环的双向链表\\循环的静态链表\end{aligned}\right.</script><h3 id="1-单链表的结构"><a href="#1-单链表的结构" class="headerlink" title="1. 单链表的结构"></a>1. 单链表的结构</h3><p>单链表就是简单的结点与结点通过指针相连，用来存储线性表中数据的结构。使用C++语言描述如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> data;<span class="comment">//方便起见，使用char代替ElemType类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span><span class="comment">//保存此结点下一个结点的地址</span></span><br><span class="line">&#125;LNode,*LList;<span class="comment">//此处LList是LNode型的指针类型即类似于#define LNode* LList</span></span><br></pre></td></tr></table></figure><h3 id="2-单链表的建立"><a href="#2-单链表的建立" class="headerlink" title="2. 单链表的建立"></a>2. 单链表的建立</h3><p>单链表的建立需要以下一些原料</p><ol><li>链表长度n；</li><li>链表中的数据；</li><li>建立链表的种类；</li><li>确定建立单链表的方法（头插/尾插）。</li></ol><p>其中第三点，用来确定所建立的链表是否带头结点。并且注意不论单链表是否带头结点，它都有头指针。对于单链表的建立，设计方法LList buildList0(string , int)使用头插法建立单链表，方法LList buildList1(string , int)使用尾插法建立单链表。注意方法的返回值为LList型（即LNode型指针）的变量，这个返回值就是头指针。</p><p>头插法（注意生成顺序和遍历顺序的不一致性）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//malloc所申请的空间系统并不会自动释放 所以我可以用一个函数去返回指针</span></span><br><span class="line"><span class="function">LList <span class="title">buildList0</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//头插法 </span></span><br><span class="line">LList L=<span class="literal">NULL</span>;<span class="comment">//头指针 </span></span><br><span class="line">LList p=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(s==<span class="string">"head"</span>)&#123;<span class="comment">//带头结点</span></span><br><span class="line">L = (LList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">p=(LList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;p-&gt;data;</span><br><span class="line">p-&gt;next=L-&gt;next;</span><br><span class="line">L-&gt;next=p;</span><br><span class="line">&#125; </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;<span class="comment">//不带头结点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">p=(LList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;p-&gt;data;</span><br><span class="line">p-&gt;next=L;</span><br><span class="line">L=p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> L;<span class="comment">//返回头指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尾插法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LList <span class="title">buildList1</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//尾插法 </span></span><br><span class="line">LList L=<span class="literal">NULL</span>;</span><br><span class="line">LList p=<span class="literal">NULL</span>;</span><br><span class="line">LList q=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(s==<span class="string">"head"</span>)&#123;<span class="comment">//带头结点</span></span><br><span class="line">L=(LList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">q=L;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">p=(LList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;p-&gt;data;</span><br><span class="line">p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">q-&gt;next=p;</span><br><span class="line">q=p;</span><br><span class="line">&#125; </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;<span class="comment">//不带头结点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">p=(LList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;p-&gt;data;</span><br><span class="line">p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)q=L=p;<span class="comment">//第一个结点特殊对待 使得后面的操作具有规律性</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q-&gt;next=p;</span><br><span class="line">q=p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单链表建立算法</p><p>头插法（方便不需要额外设置跟进指针，但是得到的序列是颠倒的）</p><ol><li>有头结点算法<ol><li>为头指针分配空间，并让头指针的next域为NULL；</li><li>生成结点，并为data域赋值，在让其next域去指向头指针的next位置；</li><li>再让头指针的next域去指向此结点；</li><li>判断生成结点个数是否达到上限，达到则算法结束，否则回到2。</li></ol></li><li>无头结点算法<ol><li>令头指针指向NULL</li><li>生成结点，并为data域赋值，在让其next域去指向头指针的位置；</li><li>令头指针去指向此结点；</li><li>判断生成结点个数是否达到上限，达到则算法结束，否则回到2。</li></ol></li></ol><p>尾插法（较为不方便，需要设置跟进指针q，q指针起到对结点的操纵作用）</p><ol><li>有头结点算法<ol><li>为头指针L分配空间，并让头指针的next域为NULL；</li><li>设置跟进指针q，并令其指向L；</li><li>生成结点p，并为data域赋值，在让其next域为NULL；</li><li>令q的next域指向p；</li><li>令q指向p；</li><li>判断生成结点个数是否达到上限，达到则算法结束，否则回到3。</li></ol></li><li>无头结点算法（较复杂，需要对第一个分配的结点特殊对待）<ol><li>令头指针L为NULL；</li><li>生成结点p，并为data域赋值，在让其next域为NULL；</li><li>判断p是否是第一个分配的结点，若不是则进入5，否则4；</li><li>令L去指向p并令q指向L，跳到7。</li><li>令q的next指向p；</li><li>令q指向p；</li><li>判断生成结点个数是否达到上限，达到则算法结束，否则回到2。</li></ol></li></ol><p>时间复杂度分析</p><p>单链表建立算法的原操作是为指针分配空间，所以可以得到复杂度与链表长度n有关，所以可得</p><script type="math/tex; mode=display">O(n)</script><h3 id="3-对单链表中元素的访问"><a href="#3-对单链表中元素的访问" class="headerlink" title="3. 对单链表中元素的访问"></a>3. 对单链表中元素的访问</h3><p>对单链表中元素的访问分为两种</p><h5 id="1-访问第i个元素"><a href="#1-访问第i个元素" class="headerlink" title="1. 访问第i个元素"></a>1. 访问第i个元素</h5><p>设计方法char getElem(int ,LList, string)来获得链表中i号位置的结点中存储的元素ai。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getElem</span><span class="params">(<span class="keyword">int</span> i,LList L,<span class="built_in">string</span> kind)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(kind==<span class="string">"head"</span>)&#123;</span><br><span class="line">L=L-&gt;next;<span class="comment">//消除带头和不带头结点的单链表之间的差异 统一按照无头处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(L&amp;&amp;j&lt;i)&#123;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for(int j=1;j&lt;i&amp;&amp;L;j++)&#123;</span></span><br><span class="line"><span class="comment">    L=L-&gt;next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">if</span>(!L||j&gt;i)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//思考此处!L条件是否可以换成j&lt;i？不可以 !L不等价于j&lt;i</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> L-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析</p><p>访问长度为n的单链表中第i个元素就是要找到单链表中第i个结点的位置，其中给出的位置信息i可能是不合法的，当i<1或i>n时为不合法位置，对于这样的i值，无法找到对应的结点。</1或i></p><p>i&lt;1时表示要寻找0号及以前的结点，显然不符合要求。不会进入循环（通过j不满足小于i判定）。</p><p>i&gt;n时表示寻找的结点在最后一个结点之后，进入循环之后，会导致L最终为空从而跳出循环。</p><p>1&lt;=i&lt;=n时会找到相应的结点，从而正常通过i==j跳出循环。</p><p>所以在跳出循环之后，我要对这几种情况分别处理，对于不正常的循环跳出，返回一个不可能的值0，否则返回当前寻找到的结点data。</p><p>时间复杂度分析</p><p>原操作是L指针的后移</p><p>i&lt;1时</p><p>后移0次</p><p>1&lt;=i&lt;=n时</p><p>当i=1时，后移次数为0，i=2时后移一次，所以i=n时，后移n-1次；</p><p>i&gt;n时</p><p>移动范围是2~n+1，所以后移n次。</p><p>所以可得时间复杂度为</p><script type="math/tex; mode=display">O(n)</script><h5 id="2-访问满足一定条件的元素"><a href="#2-访问满足一定条件的元素" class="headerlink" title="2. 访问满足一定条件的元素"></a>2. 访问满足一定条件的元素</h5><p>设计方法char getElem(LList ,string ,bool (*cmp)(char))。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getElem</span><span class="params">(LList L,<span class="built_in">string</span> kind,<span class="keyword">bool</span> (*cmp)(<span class="keyword">char</span>))</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(kind==<span class="string">"head"</span>)&#123;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(L)&#123;</span><br><span class="line"><span class="keyword">if</span>(cmp(L-&gt;data))&#123;</span><br><span class="line"><span class="keyword">return</span> L-&gt;data;<span class="comment">//返回第一个满足cmp条件的data</span></span><br><span class="line">&#125;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于无法知道满足条件的结点在单链表中的位置，所以使用最坏情况下的时间复杂度</p><script type="math/tex; mode=display">O(n)</script><h5 id="3-遍历"><a href="#3-遍历" class="headerlink" title="3. 遍历"></a>3. 遍历</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(LList L,<span class="built_in">string</span> kind)</span></span>&#123;<span class="comment">//输出链表</span></span><br><span class="line"><span class="keyword">if</span>(kind==<span class="string">"head"</span>)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"head -&gt; "</span>;</span><br><span class="line">      L=L-&gt;next;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(L)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;L-&gt;data;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">" -&gt; "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"NULL"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-插入运算"><a href="#4-插入运算" class="headerlink" title="4. 插入运算"></a>4. 插入运算</h3><p>单链表的插入运算和单链表的头插法建立类似。插入运算需要的原料有</p><ol><li>插入位置i</li><li>插入的结点（或链表）</li></ol><p>插入运算需要注意插入位置的范围，插入的位置i需要满足1&lt;=i&lt;=n+1，并且注意插入运算只要求当前结点不是空结点（线性表的插入运算类似，只要当前位置有元素，就可以在它后面插入元素），那么就可以在它后面进行插入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i,LList L,<span class="keyword">char</span> a,<span class="built_in">string</span> kind)</span></span>&#123;<span class="comment">//i插入位置、L链表、a插入结点的data</span></span><br><span class="line">LList p=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">if</span>(kind==<span class="string">"head"</span>)&#123;</span><br><span class="line">j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(L&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!L||j&gt;i<span class="number">-1</span>)<span class="built_in">cout</span>&lt;&lt;<span class="string">"插入位置不合法"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">p=(LList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">p-&gt;data=a;</span><br><span class="line">p-&gt;next=L-&gt;next;</span><br><span class="line">L-&gt;next=p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;<span class="comment">//不带头结点的链表插入位置为1时需要单独讨论</span></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">p=(LList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">p-&gt;data=a;</span><br><span class="line">p-&gt;next=L;</span><br><span class="line">L=p;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(L&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!L||j&gt;i<span class="number">-1</span>)<span class="built_in">cout</span>&lt;&lt;<span class="string">"插入位置不合法"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">p=(LList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">p-&gt;data=a;</span><br><span class="line">p-&gt;next=L-&gt;next;</span><br><span class="line">L-&gt;next=p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度分析</p><p>插入结点的原操作就是两步的赋值运算，所以时间复杂度为</p><script type="math/tex; mode=display">O(1)</script><h3 id="5-删除运算"><a href="#5-删除运算" class="headerlink" title="5. 删除运算"></a>5. 删除运算</h3><p>单链表的删除运算需要的参数是删除的位置i，要求删除位置i满足1&lt;=i&lt;=n，因为删除i号结点必须要求这个结点存在，所以删除运算的首要目标是找到i号结点的前驱结点。</p><p>注意此处存在插入运算和删除运算的区别</p><p>在插入运算中，最后一个结点是可以作为前驱（当i=n+1时）的，因为可以在最后一个结点后面插入一个结点。</p><p>而在删除运算中最后一个结点后面没有任何可以删除的结点，所以最后一个结点不可以作为前驱。</p><p>以上两条造成了两者在具体操作时的差别，对于插入操作，从前向后走，只要这个走到的这个结点不为空，那么它后面就可能成为插入的位置，而对于删除操作，从前往后走，走到的这个结点不为空的条件还不够，还需要它后面的那个结点（被删除的对象）不为空才可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(LList&amp; L,<span class="keyword">int</span> i,<span class="built_in">string</span> kind)</span></span>&#123;<span class="comment">//使用了指针的引用</span></span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">LList q=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(kind==<span class="string">"head"</span>)&#123;</span><br><span class="line">LList L1=L;</span><br><span class="line">j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(L-&gt;next&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!L-&gt;next||j&gt;i<span class="number">-1</span>)<span class="built_in">cout</span>&lt;&lt;<span class="string">"删除位置不合法"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q=L-&gt;next;</span><br><span class="line">L-&gt;next=q-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line">L=L1;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">j=<span class="number">1</span>;<span class="comment">//注意此处和带头结点的区别</span></span><br><span class="line"><span class="keyword">if</span>(L!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">q=L;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(L-&gt;next&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!L-&gt;next||j&gt;i<span class="number">-1</span>)<span class="built_in">cout</span>&lt;&lt;<span class="string">"删除位置不合法"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q=L-&gt;next;</span><br><span class="line">L-&gt;next=q-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度分析</p><p>删除结点的原操作就是三条语句，所以时间复杂度为</p><script type="math/tex; mode=display">O(1)</script><h3 id="6-有序单链表的合并"><a href="#6-有序单链表的合并" class="headerlink" title="6. 有序单链表的合并"></a>6. 有序单链表的合并</h3><p>在顺序表中也有类似的算法，用于归并两个非递减序列，但是区别在于归并两个顺序表时使用的方法是另外申请一片空间，并同时对两个序列进行比较处理，然后将相应元素放入新序列中，而有序单链表的合并不需要另外申请空间（空间复杂度较小），而是将两个链表的箭头进行拆散重连，从而使最终链表有序。</p><p>算法描述（有头结点）</p><ol><li>L1，L2进入函数；</li><li>设定跟进LNode型指针c；</li><li>设定最终链表头指针L，并让c=L=L1；</li><li>对两个有序链表L1，L2分别从<strong>第一个存储元素</strong>的结点p和q开始向后走；</li><li>比较两个结点中的元素的值，找到较小或较大的那一方a；</li><li>让跟进指针c的next置为a，并实时更新c为a，在让a向后走一步；</li><li>判断p或者q是否为空，为空则结束算法，否则进入4；</li><li>最后，将p和q中非空的那一方赋值给c-&gt;next，free(L2)。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LList <span class="title">Merge</span><span class="params">(LList L1,LList L2,<span class="built_in">string</span> kind,<span class="keyword">bool</span>(*cmp)(<span class="keyword">char</span> a,<span class="keyword">char</span> b))</span></span>&#123;</span><br><span class="line">LList L=<span class="literal">NULL</span>;</span><br><span class="line">LList c;</span><br><span class="line"><span class="keyword">if</span>(kind==<span class="string">"head"</span>)&#123;</span><br><span class="line">c=L=L1;</span><br><span class="line">LList p=L1-&gt;next;</span><br><span class="line">LList q=L2-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p&amp;&amp;q)&#123;</span><br><span class="line"><span class="keyword">if</span>(cmp(p-&gt;data,q-&gt;data))&#123;</span><br><span class="line">c-&gt;next=p;</span><br><span class="line">c=p;</span><br><span class="line">p=p-&gt;next; </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">c-&gt;next=q;</span><br><span class="line">c=q;</span><br><span class="line">q=q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">c-&gt;next=q?q:p;</span><br><span class="line"><span class="built_in">free</span>(L2);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">c=L=(cmp(L1-&gt;data,L2-&gt;data)?L1:L2);</span><br><span class="line"><span class="keyword">if</span>(cmp(L1-&gt;data,L2-&gt;data))&#123;</span><br><span class="line">L1=L1-&gt;next;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">L2=L2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(L1&amp;&amp;L2)&#123;</span><br><span class="line"><span class="keyword">if</span>(cmp(L1-&gt;data,L2-&gt;data))&#123;</span><br><span class="line">c-&gt;next=L1;</span><br><span class="line">c=L1;</span><br><span class="line">L1=L1-&gt;next;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">c-&gt;next=L2;</span><br><span class="line">c=L2;</span><br><span class="line">L2=L2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">c-&gt;next=L1?L1:L2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&lt;=b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度分析</p><p>原操作是<strong>对跟进指针c的移动</strong>，所以可得到时间按复杂度为两者长度之和</p><script type="math/tex; mode=display">O(m+n)</script><h3 id="7-单链表的销毁"><a href="#7-单链表的销毁" class="headerlink" title="7. 单链表的销毁"></a>7. 单链表的销毁</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(LList L,<span class="built_in">string</span> kind)</span></span>&#123;</span><br><span class="line">LList q=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(kind==<span class="string">"head"</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(L-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">q=L-&gt;next;</span><br><span class="line">L-&gt;next=q-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(L);<span class="comment">//注意带头结点的链表的头结点的释放</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(L)&#123;</span><br><span class="line">q=L;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h3><p>对于单链表需要了解</p><ol><li>单链表的结构；</li><li>单链表的基本操作（建立，插入，删除，销毁）；</li><li>单链表合并算法；</li><li>访问单链表中某一元素；</li><li>单链表相比顺序表的优点（插入和删除）和缺点（访问元素）。</li></ol><h3 id="9-测试程序"><a href="#9-测试程序" class="headerlink" title="9. 测试程序"></a>9. 测试程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LList;</span><br><span class="line"><span class="function">LList <span class="title">buildList1</span><span class="params">(<span class="keyword">int</span> n,<span class="built_in">string</span> kind)</span></span>&#123;</span><br><span class="line">LList L=<span class="literal">NULL</span>;</span><br><span class="line">LList p=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span> *a=<span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(kind==<span class="string">"head"</span>)&#123;</span><br><span class="line">L=(LList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LList));</span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">p=(LList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">p-&gt;data=a[i];</span><br><span class="line">p-&gt;next=L-&gt;next;</span><br><span class="line">L-&gt;next=p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">p=(LList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">p-&gt;data=a[i];</span><br><span class="line">p-&gt;next=L;</span><br><span class="line">L=p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] a;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getElem</span><span class="params">(LList L,<span class="built_in">string</span> kind,<span class="keyword">bool</span> (*cmp)(<span class="keyword">char</span>))</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(kind==<span class="string">"head"</span>)&#123;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(L)&#123;</span><br><span class="line"><span class="keyword">if</span>(cmp(L-&gt;data))&#123;</span><br><span class="line"><span class="keyword">return</span> L-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getElem</span><span class="params">(<span class="keyword">int</span> i,LList L,<span class="built_in">string</span> kind)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(kind==<span class="string">"head"</span>)&#123;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(L&amp;&amp;j&lt;i)&#123;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!L||j&gt;i)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> L-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(LList L,<span class="built_in">string</span> kind)</span></span>&#123;</span><br><span class="line">LList q=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(kind==<span class="string">"head"</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(L-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">q=L-&gt;next;</span><br><span class="line">L-&gt;next=q-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(L);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(L)&#123;</span><br><span class="line">q=L;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(LList L,<span class="built_in">string</span> kind)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(kind==<span class="string">"head"</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"head -&gt; "</span>;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(L)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;L-&gt;data;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">" -&gt; "</span>;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"NULL"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i,LList L,<span class="keyword">char</span> a,<span class="built_in">string</span> kind)</span></span>&#123;</span><br><span class="line">LList p=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">if</span>(kind==<span class="string">"head"</span>)&#123;</span><br><span class="line">j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(L&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!L||j&gt;i<span class="number">-1</span>)<span class="built_in">cout</span>&lt;&lt;<span class="string">"插入位置不合法"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">p=(LList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">p-&gt;data=a;</span><br><span class="line">p-&gt;next=L-&gt;next;</span><br><span class="line">L-&gt;next=p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">p=(LList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">p-&gt;data=a;</span><br><span class="line">p-&gt;next=L;</span><br><span class="line">L=p;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(L&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!L||j&gt;i<span class="number">-1</span>)<span class="built_in">cout</span>&lt;&lt;<span class="string">"插入位置不合法"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">p=(LList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">p-&gt;data=a;</span><br><span class="line">p-&gt;next=L-&gt;next;</span><br><span class="line">L-&gt;next=p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(LList&amp; L,<span class="keyword">int</span> i,<span class="built_in">string</span> kind)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">LList q=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(kind==<span class="string">"head"</span>)&#123;</span><br><span class="line">LList L1=L;</span><br><span class="line">j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(L-&gt;next&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!L-&gt;next||j&gt;i<span class="number">-1</span>)<span class="built_in">cout</span>&lt;&lt;<span class="string">"删除位置不合法"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q=L-&gt;next;</span><br><span class="line">L-&gt;next=q-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line">L=L1;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">q=L;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(L-&gt;next&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!L-&gt;next||j&gt;i<span class="number">-1</span>)<span class="built_in">cout</span>&lt;&lt;<span class="string">"删除位置不合法"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q=L-&gt;next;</span><br><span class="line">L-&gt;next=q-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function">LList <span class="title">Merge</span><span class="params">(LList L1,LList L2,<span class="built_in">string</span> kind,<span class="keyword">bool</span>(*cmp)(<span class="keyword">char</span> a,<span class="keyword">char</span> b))</span></span>&#123;</span><br><span class="line">LList L=<span class="literal">NULL</span>;</span><br><span class="line">LList c;</span><br><span class="line"><span class="keyword">if</span>(kind==<span class="string">"head"</span>)&#123;</span><br><span class="line"></span><br><span class="line">c=L=L1;</span><br><span class="line">LList p=L1-&gt;next;</span><br><span class="line">LList q=L2-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p&amp;&amp;q)&#123;</span><br><span class="line"><span class="keyword">if</span>(cmp(p-&gt;data,q-&gt;data))&#123;</span><br><span class="line">c-&gt;next=p;</span><br><span class="line">c=p;</span><br><span class="line">p=p-&gt;next; </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">c-&gt;next=q;</span><br><span class="line">c=q;</span><br><span class="line">q=q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">c-&gt;next=q?q:p;</span><br><span class="line"><span class="built_in">free</span>(L2);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">c=L=(cmp(L1-&gt;data,L2-&gt;data)?L1:L2);</span><br><span class="line"><span class="keyword">if</span>(cmp(L1-&gt;data,L2-&gt;data))&#123;</span><br><span class="line">L1=L1-&gt;next;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">L2=L2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(L1&amp;&amp;L2)&#123;</span><br><span class="line"><span class="keyword">if</span>(cmp(L1-&gt;data,L2-&gt;data))&#123;</span><br><span class="line">c-&gt;next=L1;</span><br><span class="line">c=L1;</span><br><span class="line">L1=L1-&gt;next;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">c-&gt;next=L2;</span><br><span class="line">c=L2;</span><br><span class="line">L2=L2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">c-&gt;next=L1?L1:L2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&lt;=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">LList L1,L2;</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">L1=buildList1(m,<span class="string">"nonhead"</span>);</span><br><span class="line">L2=buildList1(n,<span class="string">"nonhead"</span>);</span><br><span class="line">LList L3=Merge(L1,L2,<span class="string">"nonhead"</span>,cmp1);<span class="comment">//递增 </span></span><br><span class="line">show(L3,<span class="string">"nonhead"</span>);</span><br><span class="line">destroy(L3,<span class="string">"nonhead"</span>);</span><br><span class="line"><span class="comment">/*LList L;</span></span><br><span class="line"><span class="comment">int n;</span></span><br><span class="line"><span class="comment">cin&gt;&gt;n;</span></span><br><span class="line"><span class="comment">L=buildList1(n,"head");</span></span><br><span class="line"><span class="comment">show(L,"head"); </span></span><br><span class="line"><span class="comment">//cout&lt;&lt;getElem(3,L,"head")&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">insert(4,L,'b',"head");</span></span><br><span class="line"><span class="comment">show(L,"head");</span></span><br><span class="line"><span class="comment">del(L,4,"head");</span></span><br><span class="line"><span class="comment">show(L,"head"); </span></span><br><span class="line"><span class="comment">destroy(L,"head");</span></span><br><span class="line"><span class="comment">L=buildList1(n,"nonhead");</span></span><br><span class="line"><span class="comment">show(L,"nonhead");</span></span><br><span class="line"><span class="comment">insert(4,L,'b',"nonhead");</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;getElem(3,L,"nonhead")&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">show(L,"nonhead"); </span></span><br><span class="line"><span class="comment">del(L,4,"nonhead");</span></span><br><span class="line"><span class="comment">show(L,"nonhead");</span></span><br><span class="line"><span class="comment">destroy(L,"nonhead"); */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;线性表的表示方式有顺序表和链表两种，其中顺序表是一种随机存取结构，可以根据其逻辑顺序和存储顺序一致的特性从而可以根据其中某一个元素的地址推算出其他所有元素的地址，有公式如下，其中d是每一个元素所占的内存大小&lt;/p&gt;
&lt;script typ
      
    
    </summary>
    
      <category term="数据结构" scheme="https://yys123456.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="单链表" scheme="https://yys123456.github.io/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>1026</title>
    <link href="https://yys123456.github.io/2019/07/18/PAT-1026/"/>
    <id>https://yys123456.github.io/2019/07/18/PAT-1026/</id>
    <published>2019-07-18T13:17:44.000Z</published>
    <updated>2019-07-22T12:33:09.172Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">int</span> s1=(b-a)/<span class="number">100</span>;</span><br><span class="line"><span class="keyword">double</span> s2=<span class="keyword">double</span>(b-a)/<span class="number">100</span>;</span><br><span class="line"><span class="keyword">double</span> c=s2-s1;</span><br><span class="line"><span class="keyword">if</span>(c&gt;=<span class="number">0.5</span>)&#123;</span><br><span class="line">s1+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> h;</span><br><span class="line"><span class="keyword">int</span> m=<span class="number">0</span>;</span><br><span class="line">h=s1/<span class="number">3600</span>;</span><br><span class="line"><span class="keyword">if</span>(s1&gt;=<span class="number">3600</span>)&#123;</span><br><span class="line">s1-=h*<span class="number">3600</span>;</span><br><span class="line">&#125;</span><br><span class="line">m=s1/<span class="number">60</span>;</span><br><span class="line"><span class="keyword">if</span>(s1&gt;=<span class="number">60</span>)&#123;</span><br><span class="line">s1-=m*<span class="number">60</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d\n"</span>,h,m,s1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="pat" scheme="https://yys123456.github.io/categories/pat/"/>
    
    
      <category term="pat" scheme="https://yys123456.github.io/tags/pat/"/>
    
  </entry>
  
  <entry>
    <title>顺序表</title>
    <link href="https://yys123456.github.io/2019/07/13/2019-07-10-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    <id>https://yys123456.github.io/2019/07/13/2019-07-10-数据结构——顺序表/</id>
    <published>2019-07-13T03:36:24.000Z</published>
    <updated>2019-07-22T12:33:47.771Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>顺序表是线性表的一种，顺序表的特殊性在于顺序表用一组地址连续的存储单元依次存储线性表的数据元素，所以就导致了顺序表这种数据结构中数据元素之间的逻辑关系和物理存储位置是一致的，所以在顺序表中，已知一个数据元素的地址，可以推算出其他所有元素的地址，即顺序表是一种随机存取的结构。</p><h3 id="1-顺序表的表示"><a href="#1-顺序表的表示" class="headerlink" title="1. 顺序表的表示"></a>1. 顺序表的表示</h3><p>在数据结构教材中将顺序表这种数据结构封装成了C语言中的struct类型，而C语言中的数组结构就很类似于顺序表，顺序表结构具有顺序表起始地址elem、顺序表长度len和顺序表最大长度size这三个成员。</p><p>顺序表SqList类型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">ElemType* elem;<span class="comment">//ElemType可以选择任意基本、类或结构类型</span></span><br><span class="line"><span class="keyword">int</span> len;<span class="comment">//顺序表的所存储的元素个数</span></span><br><span class="line"><span class="keyword">int</span> size;<span class="comment">//顺序表总大小（以sizeof(ElemType)为单位）</span></span><br><span class="line">&#125;SqList;<span class="comment">//将这个结构类型重命名为SqList</span></span><br></pre></td></tr></table></figure><h3 id="2-顺序表的初始化"><a href="#2-顺序表的初始化" class="headerlink" title="2. 顺序表的初始化"></a>2. 顺序表的初始化</h3><p>由于使用SqList定义一个顺序表类型的变量，并未给其中的elem指针分配一块连续存储单元，所以需要使用C语言中的malloc函数为elem指针进行分配空间，先定义一个初始的最大空间以及一个增量空间，方便起见使用int类型来替换ElemType自定义类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITSIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INCRSIZE 10</span></span><br></pre></td></tr></table></figure><p>对顺序表的初始化举例如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">INITLIST</span><span class="params">(SqList&amp;s)</span></span>&#123;<span class="comment">//使用了引用</span></span><br><span class="line">    s.elem=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(INITSIZE*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(!s.elem)<span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//确保程序的健壮性</span></span><br><span class="line">    s.len=<span class="number">0</span>;<span class="comment">//初始长度为0</span></span><br><span class="line">    s.size=INITSIZE;<span class="comment">//总大小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqList sq;</span><br><span class="line">INITLIST(sq);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-顺序表的插入运算"><a href="#3-顺序表的插入运算" class="headerlink" title="3. 顺序表的插入运算"></a>3. 顺序表的插入运算</h3><p>抛开前面的顺序表类型不谈，对一个顺序表进行插入运算分为以下步骤：</p><ol><li>确定插入位置；</li><li>进行元素的移动；</li><li>插入元素。</li></ol><p>由于无法预测到输入数据的插入位置是否满足合法性，所以需要进行插入位置的合法性检查，另外插入运算需要对顺序表中的元素进行移动，比如，要求在长度为n的顺序表中的i（1&lt;=i&lt;=n+1）号位置插入一个元素，就需要先将i号位置空出来，就需要将i~n的所有元素整体向后移动位置,在对i位置赋值，使用简单的整型数组结合循环语句可以表达如下（注意下标的转换）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>;j&gt;=i<span class="number">-1</span>;j--)&#123;</span><br><span class="line">a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">&#125;</span><br><span class="line">a[i<span class="number">-1</span>]=e;<span class="comment">//e为要插入的数值</span></span><br><span class="line">n++;<span class="comment">//长度增加一个</span></span><br></pre></td></tr></table></figure><p>使用教材上的结构体描述如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LISTINSERT</span><span class="params">(SqList&amp;s,<span class="keyword">int</span> e,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;n+<span class="number">1</span>)<span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//插入位置不合理</span></span><br><span class="line"><span class="keyword">if</span>(s.len==s.size)&#123;<span class="comment">//此时无法再插入元素需要重新分配</span></span><br><span class="line">        s.elem=(<span class="keyword">int</span>*)<span class="built_in">realloc</span>(s.elem,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(INCRSIZE+s.size));</span><br><span class="line">        <span class="keyword">if</span>(!s.elem)<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=s.len<span class="number">-1</span>;j&gt;=i<span class="number">-1</span>;j--)&#123;</span><br><span class="line">            s.elem[j+<span class="number">1</span>]=s.elem[j];</span><br><span class="line">        &#125;</span><br><span class="line">        s.elem[i<span class="number">-1</span>]=e;</span><br><span class="line">        s.len++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度分析</p><p>顺序表的插入运算会涉及到元素的移动，所以不同的插入位置会导致不同的时间复杂度，考虑在最坏的情况下（即插入位置在1号位置）的时间复杂度，需要将1~n的所有数据元素向后移动一个，所以可以得出最坏情况下的时间复杂度为</p><script type="math/tex; mode=display">O(n)</script><p>考虑平均移动元素的个数，可以得到以下表达式</p><script type="math/tex; mode=display">AVG_{times}=\frac{1}{n+1}\sum_{k=1}^{n+1} {(n-k+1)}</script><p>求得结果为</p><script type="math/tex; mode=display">\frac{n}{2}</script><p>由此可以得到平均时间复杂度为</p><script type="math/tex; mode=display">O(n)</script><h3 id="4-顺序表的删除运算"><a href="#4-顺序表的删除运算" class="headerlink" title="4. 顺序表的删除运算"></a>4. 顺序表的删除运算</h3><p>顺序表的删除运算包括以下步骤：</p><ol><li>确定删除位置；</li><li>进行元素移动；</li><li>完成删除。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="comment">//位于struct中的删除方法</span></span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;len)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;len;j++)&#123;</span><br><span class="line">elem[j<span class="number">-1</span>]=elem[j];<span class="comment">//原操作</span></span><br><span class="line">&#125;</span><br><span class="line">len--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度分析</p><p>将一个顺序表中的一个元素删除所需要移动的元素的个数和删除元素的位置有关，在最坏情况下，也就是删除顺序表中的第一个元素，需要将2~n的所有元素向前移动一个，所以一共移动了n-1次，可以得到最坏时间复杂度为</p><script type="math/tex; mode=display">O(n)</script><p>平均时间复杂度分析</p><p>求平均时间复杂度就是求解选取所有删除位置时需要移动的平均次数，删除第一个需要移动n-1个元素，删除第二个需要移动n-2个元素……以此类推可得平均移动次数的计算公式</p><script type="math/tex; mode=display">AVG_{times}=\frac{1}{n}\sum_{i=1}^{n}{(n-i)}</script><p>所以可以计算得到平均移动次数为</p><script type="math/tex; mode=display">\frac{n-1}{2}</script><p>所以可以得到平均时间复杂度为</p><script type="math/tex; mode=display">O(n)</script><h3 id="5-顺序表的合并"><a href="#5-顺序表的合并" class="headerlink" title="5. 顺序表的合并"></a>5. 顺序表的合并</h3><p>顺序表的合并是将两个顺序表简单的合并到一起，不考虑元素顺序和重复。设被合并的两个顺序表的长度分别为m和n。</p><p>方法一：</p><p>直接将一个顺序表接在另一个的后面（基于插入）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SqList&amp; <span class="title">MergeList1</span><span class="params">(SqList&amp;a,SqList&amp;b)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.len;i++)&#123;</span><br><span class="line">a.insert(b.elem[i],a.len+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><p>将两个顺序表进行排序后在合并到一个新的顺序表中（基于复制）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SqList <span class="title">MergeList2</span><span class="params">(SqList&amp;a,SqList&amp;b)</span></span>&#123;</span><br><span class="line">SqList c; <span class="comment">//新表</span></span><br><span class="line"><span class="built_in">free</span>(c.elem);</span><br><span class="line">c.elem=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>((a.len+b.len)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//不分配多余的空间</span></span><br><span class="line"><span class="keyword">int</span>* k=c.elem;</span><br><span class="line">    c.size=c.len=a.len+b.len; </span><br><span class="line">sort(a.elem,a.elem+a.len);</span><br><span class="line">sort(b.elem,b.elem+b.len);</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;a.len&amp;&amp;j&lt;b.len;)&#123;</span><br><span class="line"><span class="keyword">if</span>(a.elem[i]&lt;=b.elem[j])&#123;</span><br><span class="line">*k++=a.elem[i];</span><br><span class="line">i++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">*k++=b.elem[j];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;a.len)&#123;</span><br><span class="line">*k++=a.elem[i];</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(j&lt;b.len)&#123;</span><br><span class="line">*k++=b.elem[j];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度分析</p><p>方法一的时间复杂度显然为</p><script type="math/tex; mode=display">O(n)</script><p>方法二的时间复杂度与两个顺序表的长度都相关</p><script type="math/tex; mode=display">O(m+n)</script><h3 id="6-顺序表求并集"><a href="#6-顺序表求并集" class="headerlink" title="6. 顺序表求并集"></a>6. 顺序表求并集</h3><p>顺序表求并集需要注意的问题是相同元素的排除（不再插入），所以最简单的方法就是对表a进行遍历，每次从a中拿出一个元素然后再遍历表b，若表b中不存在此元素，就将其插入（位置自选，此处选择复杂度最小的在尾部插入），否则不插入。所以方法一如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> SqList::Locate(<span class="keyword">int</span> e,<span class="keyword">bool</span> (*cmp)(<span class="keyword">int</span>,<span class="keyword">int</span>))&#123;<span class="comment">//确定值e在顺序表的位置</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len&amp;&amp;!((*cmp)(e,elem[i]));i++);</span><br><span class="line"><span class="keyword">if</span>(i==len)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SqList&amp; <span class="title">unionList1</span><span class="params">(SqList&amp;a,SqList&amp;b)</span></span>&#123;<span class="comment">//结果保存于a中</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.len;i++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(a.Locate(b.elem[i],cmp)==<span class="number">-1</span>)&#123;</span><br><span class="line"> a.insert(b.elem[i],a.len+<span class="number">1</span>);<span class="comment">//在尾部插入</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a==b;<span class="comment">//原操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度分析</p><p>由于每次取出b中的元素后，都要对a遍历一遍，所以比较总次数为m*n。所以时间复杂度为</p><script type="math/tex; mode=display">O(mn)</script><p>虽然这种方法思路简单，但是时间复杂度较大。</p><p>方法二：</p><p>造成方法一时间耗费长的主要原因是每次都对顺序表进行完整的遍历，所以可以先对被比较的顺序表进行排序（使用升序）。</p><p>算法思路</p><ol><li>取出b中的一个元素x；</li><li>从a的第一个元素开始遍历；</li><li>找a中第一个不满足比x小的元素y；</li><li>若x==y则不插入，否则插入。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SqList&amp; <span class="title">unionList3</span><span class="params">(SqList&amp;a,SqList&amp;b)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.len;i++)&#123;</span><br><span class="line">        sort(a.elem,a.elem+a.len);<span class="comment">//快速排序</span></span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(b.elem[i]&gt;a.elem[j]&amp;&amp;j&lt;a.len)j++;</span><br><span class="line"><span class="keyword">if</span>(j==a.len||b.elem[i]&lt;a.elem[j])&#123;</span><br><span class="line">a.insert(b.elem[i],j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度分析</p><p>由于无法确定a被遍历的元素个数，所以选择最坏情况分析，在最坏情况下（b和a中的元素全部不合适）为</p><script type="math/tex; mode=display">O(mn)</script><p>方法三：</p><p>使用基于复制的方法，需要将两个顺序表都进行排序（使用升序）。</p><p>算法思路</p><ol><li>将a和b两个顺序表进行升序排序；</li><li>分配一段连续的存储空间c作为结果；</li><li>设定两个指针pa和pb；</li><li>使用pa和pb对a和b进行扫描；</li><li>比较pa和pb所指向的值的大小；</li><li>大小分为三种情况，*pa==*pb，*pa&gt;*pb，*pa&lt;*pb，分别对应三种操作。</li></ol><p>*pa==*pb：将任意一方的值赋值给c，然后pa++；pb++；pc++；</p><p>*pa&gt;*pb：将*pb赋值给c，pb++；pc++；</p><p>*pa&lt;*pb：将*pa赋值给c，pa++；pc++；</p><p>直到a或b已经走到尽头，然后将没有走到尽头的那一方的后续元素接在c后面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SqList <span class="title">unionList2</span><span class="params">(SqList&amp;a,SqList&amp;b)</span></span>&#123;</span><br><span class="line">SqList c;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">i=j=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">free</span>(c.elem);</span><br><span class="line">c.elem=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>((a.len+b.len)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">int</span>*k=c.elem;</span><br><span class="line">c.size=a.len+b.len;</span><br><span class="line">c.len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!c.elem)<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">sort(a.elem,a.elem+a.len);<span class="comment">//先排序 暂时不考虑它造成的时间消耗</span></span><br><span class="line">sort(b.elem,b.elem+b.len);</span><br><span class="line"><span class="keyword">while</span>(i&lt;a.len&amp;&amp;j&lt;b.len)&#123;</span><br><span class="line"><span class="keyword">switch</span>(a.elem[i]&lt;=b.elem[j])&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line"><span class="keyword">if</span>(a.elem[i]&lt;b.elem[j])&#123;</span><br><span class="line">*k++=a.elem[i];</span><br><span class="line">c.len++;<span class="comment">//注意c的长度的标记，因为c的最终长度&lt;=a.len+b.len</span></span><br><span class="line">i++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">*k++=a.elem[i];</span><br><span class="line">c.len++;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">*k++=b.elem[j];</span><br><span class="line">c.len++;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;a.len)&#123;</span><br><span class="line">*k++=a.elem[i];</span><br><span class="line">c.len++;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(j&lt;b.len)&#123;</span><br><span class="line">*k++=b.elem[j];</span><br><span class="line">c.len++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法复杂度分析</p><p>由于原操作是给c赋值，所以对c进行赋值的次数统计得到总赋值次数&lt;=m+n，所以可以得到时间复杂度为</p><script type="math/tex; mode=display">O(m+n)</script><p>相比直接简单求并集，复杂度有所减小，但是出现了额外的辅助空间，即c所代表的一段空间。</p><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><p>需要了解：</p><ol><li>顺序表属于线性表；</li><li>顺序表的定义；</li><li>顺序表的基本操作（增删改查，合并，并集）及其优化算法和复杂度；</li><li>顺序表的结构；</li><li>一般使用数组代替顺序表进行相关操作。</li></ol><h3 id="8-测试程序"><a href="#8-测试程序" class="headerlink" title="8. 测试程序"></a>8. 测试程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INITSIZE=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INCRESIZE=<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SqList</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span>* elem;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">int</span> size;<span class="comment">//以sizeof(int)做单位 </span></span><br><span class="line">SqList()&#123;</span><br><span class="line">elem=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(INITSIZE*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span>(!elem)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"空间分配失败"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">len=<span class="number">0</span>;</span><br><span class="line">size=<span class="keyword">sizeof</span>(elem)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br><span class="line">SqList(SqList&amp;s);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Locate</span><span class="params">(<span class="keyword">int</span> e,<span class="keyword">bool</span> (*cmp)(<span class="keyword">int</span>,<span class="keyword">int</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> e,<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;len)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;len;j++)&#123;</span><br><span class="line">elem[j<span class="number">-1</span>]=elem[j];</span><br><span class="line">&#125;</span><br><span class="line">len--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line">~SqList()&#123;</span><br><span class="line"><span class="built_in">free</span>(elem);</span><br><span class="line">&#125;</span><br><span class="line">SqList&amp;<span class="keyword">operator</span>=(SqList&amp;t)&#123;</span><br><span class="line"><span class="built_in">free</span>(elem);</span><br><span class="line">elem=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(t.size*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">len=t.len;</span><br><span class="line">size=t.size;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.len;i++)&#123;</span><br><span class="line">elem[i]=t.elem[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br><span class="line">SqList::SqList(SqList&amp;s)&#123;</span><br><span class="line">elem=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(s.size*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">len=s.len;</span><br><span class="line">size=s.size;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.len;i++)&#123;</span><br><span class="line">elem[i]=s.elem[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;out,<span class="keyword">const</span> SqList&amp;s)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.len;i++)&#123;</span><br><span class="line">out&lt;&lt;s.elem[i];</span><br><span class="line">&#125;</span><br><span class="line">out&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> SqList::Locate(<span class="keyword">int</span> e,<span class="keyword">bool</span> (*cmp)(<span class="keyword">int</span>,<span class="keyword">int</span>))&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len&amp;&amp;!((*cmp)(e,elem[i]));i++);</span><br><span class="line"><span class="keyword">if</span>(i==len)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> SqList::insert(<span class="keyword">int</span> e,<span class="keyword">int</span> i)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;len+<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">if</span>(len==size)&#123;</span><br><span class="line">elem=(<span class="keyword">int</span>*)<span class="built_in">realloc</span>(elem,(size+INCRESIZE)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!elem)<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=len<span class="number">-1</span>;j&gt;=i<span class="number">-1</span>;j--)&#123;</span><br><span class="line">elem[j+<span class="number">1</span>]=elem[j];</span><br><span class="line">&#125;</span><br><span class="line">elem[i<span class="number">-1</span>]=e;</span><br><span class="line">len++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SqList <span class="title">MergeList2</span><span class="params">(SqList&amp;a,SqList&amp;b)</span></span>&#123;</span><br><span class="line">SqList c; </span><br><span class="line"><span class="built_in">free</span>(c.elem);</span><br><span class="line">c.elem=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>((a.len+b.len)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">int</span>* k=c.elem;</span><br><span class="line">c.len=a.len+b.len; </span><br><span class="line">sort(a.elem,a.elem+a.len);</span><br><span class="line">sort(b.elem,b.elem+b.len);</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;a.len&amp;&amp;j&lt;b.len;)&#123;</span><br><span class="line"><span class="keyword">if</span>(a.elem[i]&lt;=b.elem[j])&#123;</span><br><span class="line">*k++=a.elem[i];</span><br><span class="line">i++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">*k++=b.elem[j];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;a.len)&#123;</span><br><span class="line">*k++=a.elem[i];</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(j&lt;b.len)&#123;</span><br><span class="line">*k++=b.elem[j];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SqList&amp; <span class="title">MergeList1</span><span class="params">(SqList&amp;a,SqList&amp;b)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.len;i++)&#123;</span><br><span class="line">a.insert(b.elem[i],a.len+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SqList&amp; <span class="title">unionList1</span><span class="params">(SqList&amp;a,SqList&amp;b)</span></span>&#123;<span class="comment">//结果保存于a中</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.len;i++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(a.Locate(b.elem[i],cmp)==<span class="number">-1</span>)&#123;</span><br><span class="line"> a.insert(b.elem[i],a.len+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SqList&amp; <span class="title">unionList3</span><span class="params">(SqList&amp;a,SqList&amp;b)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.len;i++)&#123;</span><br><span class="line">sort(a.elem,a.elem+a.len);</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(b.elem[i]&gt;a.elem[j]&amp;&amp;j&lt;a.len)j++;</span><br><span class="line"><span class="keyword">if</span>(j==a.len||b.elem[i]&lt;a.elem[j])&#123;</span><br><span class="line">a.insert(b.elem[i],j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function">SqList <span class="title">unionList2</span><span class="params">(SqList&amp;a,SqList&amp;b)</span></span>&#123;</span><br><span class="line">SqList c;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">i=j=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">free</span>(c.elem);</span><br><span class="line">c.elem=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>((a.len+b.len)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">int</span>*k=c.elem;</span><br><span class="line">c.size=a.len+b.len;</span><br><span class="line">c.len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!c.elem)<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">sort(a.elem,a.elem+a.len);</span><br><span class="line">sort(b.elem,b.elem+b.len);</span><br><span class="line"><span class="keyword">while</span>(i&lt;a.len&amp;&amp;j&lt;b.len)&#123;</span><br><span class="line"><span class="keyword">switch</span>(a.elem[i]&lt;=b.elem[j])&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line"><span class="keyword">if</span>(a.elem[i]&lt;b.elem[j])&#123;</span><br><span class="line">*k++=a.elem[i];</span><br><span class="line">c.len++;</span><br><span class="line">i++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">*k++=a.elem[i];</span><br><span class="line">c.len++;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">*k++=b.elem[j];</span><br><span class="line">c.len++;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;a.len)&#123;</span><br><span class="line">*k++=a.elem[i];</span><br><span class="line">c.len++;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(j&lt;b.len)&#123;</span><br><span class="line">*k++=b.elem[j];</span><br><span class="line">c.len++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a==b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">SqList sq1,sq2;</span><br><span class="line"><span class="keyword">int</span> len1,len2;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;len1;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;len2;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"输入顺序表1的数据:"</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">sq1.insert(a,sq1.len+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">SqList t=sq1;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"输入顺序表2的数据:"</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len2;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">sq2.insert(a,sq2.len+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"基于复制的合并结果串为:"</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;MergeList2(sq1,sq2);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"基于插入的合并结果串为(改变后的sq1):"</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;MergeList1(sq1,sq2);</span><br><span class="line">sq1=t;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"基于复制的两串求并集为:"</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;unionList2(sq1,sq2);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"基于插入的并集结果串为(改变后的sq1):"</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;unionList1(sq1,sq2); </span><br><span class="line">sq1=t;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"使用排序后的sq1求并集:"</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;unionList3(sq1,sq2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;顺序表是线性表的一种，顺序表的特殊性在于顺序表用一组地址连续的存储单元依次存储线性表的数据元素，所以就导致了顺序表这种数据结构中数据元素之间的逻辑关系和物理存储位置是一致的，所以在顺序表中，已知一个数据元素的地址，可以推算出其他所有元素的
      
    
    </summary>
    
      <category term="数据结构" scheme="https://yys123456.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="顺序表" scheme="https://yys123456.github.io/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>1024</title>
    <link href="https://yys123456.github.io/2019/07/12/PAT-1024/"/>
    <id>https://yys123456.github.io/2019/07/12/PAT-1024/</id>
    <published>2019-07-11T16:00:00.000Z</published>
    <updated>2019-07-22T12:32:51.067Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">char</span> c1;</span><br><span class="line"><span class="keyword">char</span> c=s[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;s.length();i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]==<span class="string">'+'</span>||s[i]==<span class="string">'-'</span>)&#123;</span><br><span class="line">c1=s[i];</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">while</span>(i&lt;s.length())&#123;</span><br><span class="line">p=p*<span class="number">10</span>+s[i]-<span class="string">'0'</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len=s.length();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;len;i++)&#123;</span><br><span class="line">s[i<span class="number">-1</span>]=s[i];</span><br><span class="line">&#125;</span><br><span class="line">len--;</span><br><span class="line"><span class="built_in">string</span> s1=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;s[i]!=<span class="string">'E'</span>;i++)&#123;</span><br><span class="line">s1+=s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c1==<span class="string">'+'</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(p+<span class="number">2</span>&gt;s1.length())s1+=<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(p+<span class="number">2</span>&lt;s1.length())s1.insert(p+<span class="number">2</span>,<span class="string">"."</span>);</span><br><span class="line"><span class="keyword">if</span>(s1[<span class="number">0</span>]==<span class="string">'+'</span>)</span><br><span class="line">s1.erase(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">string</span> s2=<span class="string">"."</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;p;i++)&#123;</span><br><span class="line">s2+=<span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line">s2=<span class="string">'0'</span>+s2;</span><br><span class="line"></span><br><span class="line">s1.insert(<span class="number">1</span>,s2);</span><br><span class="line"><span class="keyword">if</span>(s1[<span class="number">0</span>]==<span class="string">'+'</span>)</span><br><span class="line">s1.erase(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span
      
    
    </summary>
    
      <category term="pat" scheme="https://yys123456.github.io/categories/pat/"/>
    
    
      <category term="pat" scheme="https://yys123456.github.io/tags/pat/"/>
    
  </entry>
  
</feed>
